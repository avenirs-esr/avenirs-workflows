name: "Project to Markdown"
description: "Extract User Stories from a GitHub Project to a Markdown table"
inputs:
  token:
    required: true
    description: "GitHub App installation token"
  org:
    required: true
    description: "Organization name"
  project_number:
    required: true
    description: "Project number (not ID)"
  profil_label:
    required: true
    description: "Profil label to filter User Stories. Ex: 'Profil: Apprenant'"
  epic_label:
    required: true
    description: "Epic label to identify epics. Ex: 'Type: Epic'"
  out_file:
    required: true
    description: "Output Markdown file path"
runs:
  using: "composite"
  steps:
    - name: üõ†Ô∏è Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: 20

    - name: üìú Generate Markdown table from Project
      shell: bash
      env:
        TOKEN:          ${{ inputs.token }}
        ORG:            ${{ inputs.org }}
        PROJECT_NUMBER: ${{ inputs.project_number }}
        PROFIL_LABEL:   ${{ inputs.profil_label }}
        EPIC_LABEL:     ${{ inputs.epic_label }}
        OUT_FILE:       ${{ inputs.out_file }}
      run: |
        node - <<'NODE'
        const fs = require('fs');

        const token   = process.env.TOKEN;
        const org     = process.env.ORG;
        const number  = parseInt(process.env.PROJECT_NUMBER,10);
        const profilLabel = process.env.PROFIL_LABEL;
        const epicLabel   = process.env.EPIC_LABEL;
        const outFile     = process.env.OUT_FILE;

        const query = `
        query($org:String!, $number:Int!, $after:String){
          organization(login:$org){
            projectV2(number:$number){
              items(first:100, after:$after){
                nodes{
                  content{
                    __typename
                    ... on Issue {
                      number
                      title
                      url
                      updatedAt
                      labels(first:50){ nodes{ name } }
                      parent{ number title url labels(first:10){ nodes{ name } } }
                      subIssues(first:50){ nodes{
                          __typename
                          ... on Issue {
                            number title url labels(first:10){ nodes{ name } }
                          }
                      }}
                    }
                  }
                  fieldValues(first:5){ nodes{
                    __typename
                    ... on ProjectV2ItemFieldSingleSelectValue {
                      field { ... on ProjectV2SingleSelectField { name } }
                      name
                    }
                  }}
                }
                pageInfo{ hasNextPage endCursor }
              }
            }
          }
        }`;

        async function gql(variables){
          const r = await fetch('https://api.github.com/graphql',{
            method:'POST',
            headers:{
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
              'User-Agent': 'us-table-bot',
              'GraphQL-Features': 'tracked_issues_graphql_access, sub_issues'
            },
            body: JSON.stringify({ query, variables })
          });
          const j = await r.json();
          if (j.errors) throw new Error(JSON.stringify(j.errors,null,2));
          return j.data;
        }

        function statusOf(fieldValues){
          for (const v of fieldValues?.nodes??[]){
            if (v.__typename==='ProjectV2ItemFieldSingleSelectValue' && v.field?.name==='Status') return v.name||'Unspecified';
          }
          return 'Unspecified';
        }

        const norm = s => (s ?? "").toLowerCase().replace(/\s*:\s*/g, ":").trim();
        const labelNames = n => (n?.labels?.nodes ?? []).map(x => x.name);
        const epicWantedSet = new Set(String(epicLabel).split(',').map(s=>norm(s.trim())).filter(Boolean));

        function parseProfil(labels){
          const hit = labels.find(n=>n.startsWith('Profil : '));
          return hit ? hit.split(':')[1].trim() : '';
        }

        function findEpic(childIssue){
          const p = childIssue.parent;
          if (p) {
            const labs = new Set(labelNames(p).map(norm));
            if ([...epicWantedSet].some(w => labs.has(w))) return p.title;
            return p.title;
          }

          const parents = childIssue.trackedInIssues?.nodes ?? [];
          const labelled = parents.filter(p =>
            [...epicWantedSet].some(w => new Set(labelNames(p).map(norm)).has(w))
          );
          if (labelled.length) return labelled[0].title;
          if (parents.length === 1) return parents[0].title;

          if (parents.length) {
            console.warn(`[DEBUG] #${childIssue.number} parents non-Epic via checklist:`,
            parents.map(p => ({ title: p.title, labels: labelNames(p) })));
          }
          return null;
        }

        (async ()=>{
          let after=null, items=[];
          do{
            const d = await gql({org, number, after});
            const proj = d?.organization?.projectV2;
            if (!proj) {
              console.error('GraphQL data:', JSON.stringify(d, null, 2));
              throw new Error(
              'Project introuvable. V√©rifie:\n' +
              `- org = "${org}" (login exact de l‚Äôorganisation)\n` +
              `- project_number = ${number} (num√©ro visible dans l‚ÄôURL)\n` +
              '- le token App a "Projects: read" sur l‚Äôorg et l‚ÄôApp est install√©e sur l‚Äôorg.\n'
              );
            }
            const page = d.organization.projectV2.items;
            items.push(...page.nodes);
            after = page.pageInfo.hasNextPage ? page.pageInfo.endCursor : null;
          } while(after);

          const childToEpicTitle = new Map();
          for (const it of items) {
            const c = it.content;
            if (!c || c.__typename !== 'Issue') continue;
            const isEpic = [...epicWantedSet].some(w => new Set(labelNames(c).map(norm)).has(w));
            if (!isEpic) continue;
              for (const child of (c.subIssues?.nodes ?? [])) {
              childToEpicTitle.set(child.url, c.title);
            }
          }

          const rows = [];
          for (const it of items){
            const c = it.content;
            if (!c || c.__typename!=='Issue') continue;
            const labels = labelNames(c);
            if (!labels.includes(profilLabel)) continue;

            const profil = parseProfil(labels) || '‚Äî';
            let epic   = findEpic(c, epicWantedSet);
            if (!epic) {
              const fromMap = childToEpicTitle.get(c.url);
              if (fromMap) epic = fromMap;
            }
            const us     = c.title.replace(/\|/g,'\\|');
            const maj    = c.updatedAt?.slice(0,10) || '';
            rows.push({ profil, epic: epic || '‚Äî', us, maj });
          }

          rows.sort((a, b) => {
            const aHas = a.epic && a.epic !== '‚Äî';
            const bHas = b.epic && b.epic !== '‚Äî';
            if (aHas !== bHas) return aHas ? -1 : 1;
            const e = (a.epic || '').localeCompare(b.epic || '', 'fr', { sensitivity: 'base', numeric: true });
            if (e !== 0) return e;
            return a.us.localeCompare(b.us, 'fr', { sensitivity: 'base', numeric: true });
          });

          let md = '| Profil | Epic | US | Mise √† jour |\n|---|---|---|---|\n';
          for (const r of rows){
            md += `| ${r.profil} | ${r.epic} | ${r.us} | ${r.maj} |\n`;
          }
          fs.writeFileSync(outFile, md, 'utf8');
        })().catch(e=>{ console.error(e); process.exit(1); });
        NODE
